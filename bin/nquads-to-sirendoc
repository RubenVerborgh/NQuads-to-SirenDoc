#!/usr/bin/env node

var fs = require('fs'),
    path = require('path'),
    spawn = require('child_process').spawn,
    mkdirp = require('mkdirp'),
    byline = require('byline'),
    print = console.log;

var regComment = /^\s*#/,
    quad = /^\s*([^ ]+)\s+([^ ]+)\s+([^ ]+)\s+([^ ]+)\s*\.\s*$/;

if (process.argv.length != 4)
  error('usage:', path.basename(process.argv[1]),
                  '<nquad source> <destination>');

// Set up source and destination
var source = process.argv[2],
    destination = process.argv[3];
if(!fs.existsSync(source))
  error(source, 'does not exist');
mkdirp.sync(destination);

processBySubject(processByObject);

// Write all quads' metadata and outgoing triples
function processBySubject (callback) {
  var currentSubject,
      currentFolder,
      lineCount = 0,
      quads;
  print('Writing metadata and outgoing triples...');
  var bySubject = spawn('sort', [source]);
  byline(bySubject.stdout).on('data', function (line) {
    var quad = parseQuad(line);
    if (quad) {
      // Start a new entity if the subject is different
      if (quad.subject !== currentSubject) {
        // Write outgoing quads of previous triple,
        // since they are complete now
        if (currentSubject) {
          writeOutgoing(quads, currentFolder);
          // also create an empty incoming file
          writeIncoming([], currentFolder);
        }

        // Start new entity
        currentSubject = quad.subject;
        currentFolder = createFolder();
        writeMetadata(quad, currentFolder);
        quads = [];
      }
      // Add the quad to the list of outgoing relations
      quads.push(quad);
    }
    // Print status
    if(++lineCount % 10000 === 0)
      print('  ' + lineCount + ' lines processed');
  }).on('end', callback || function () {});
}

// Write all quad's ingoing triples
function processByObject (callback) {
  var currentObject,
      currentFolder,
      folderId = 0,
      folderSubject = '',
      lineCount = 0,
      quads;
  print('Writing incoming triples...');
  var byObject = spawn('sort', ['-k3', source]);
  byline(byObject.stdout).on('data', function (line) {
    var quad = parseQuad(line);
    if (quad) {
      // Start a new entity if the object is different
      if (quad.object !== currentObject) {
        // Write incoming quads of previous triple,
        // since they are complete now
        if (folderSubject && currentObject === folderSubject)
          writeIncoming(quads, currentFolder);

        // Start new entity
        currentObject = quad.object;
        // Find the folder that belongs to the entity
        while (folderSubject !== undefined && folderSubject < currentObject)
          folderSubject = getMetadataSubject(getFolderName(++folderId));
        currentFolder = getFolderName(folderId);
        quads = [];
      }
      // Add the quad to the list of incoming relations
      quads.push(quad);
    }
    // Print status
    if(++lineCount % 10000 === 0)
      print('  ' + lineCount + ' lines processed');
  }).on('end', callback || function () {});
}

// Create a folder for a quad
var entityCount = 0,
    maxFolderEntities = 1000,
    idLength = 5;
function createFolder() {
  var folder = getFolderName(++entityCount);
  mkdirp.sync(folder);
  return folder;
}

// Get the folder name based on the entity number
function getFolderName(entityNumber) {
  var docId = Math.floor(entityNumber / maxFolderEntities).toString(),
      entityId = (entityNumber % maxFolderEntities).toString(),
      folder = destination;

  // zero-padded document ID
  folder += '/docID';
  for(var i = docId.length; i < idLength; i++)
    folder += '0';
  folder += docId;

  // zero-padded entity ID
  folder += '/entityID';
  for(var i = entityId.length; i < idLength; i++)
    folder += '0'
  folder += entityId;

  return folder + '/';
}

// Write metadata file for a quad
function writeMetadata(quad, currentFolder) {
  fs.writeFileSync(currentFolder + 'metadata',
                   quad.context + '\n' + quad.subject);
}

// Write the quads as outgoing triples
function writeOutgoing(quads, currentFolder) {
  writeAsTriples(quads, currentFolder + 'outgoing-triples.nt');
}

// Write the quads as incoming triples
function writeIncoming(quads, currentFolder) {
  writeAsTriples(quads, currentFolder + 'incoming-triples.nt');
}

// Write the quads as triples
function writeAsTriples(quads, file) {
  var triples = '';
  for (var i = 0; i < quads.length; i++)
    triples += quads[i].subject + ' ' + quads[i].predicate + ' ' + quads[i].object + ' .\n';
  fs.writeFileSync(file, triples);
}

// Parse a quad into components
function parseQuad(line) {
  if (!line.match(regComment)) {
    var match = line.match(quad);
    if (match)
      return { subject:   match[1],
               predicate: match[2],
               object:    match[3],
               context:   match[4],
             };
  }
}

// Get the entity subject from the metadata
function getMetadataSubject(folder) {
  var metadataFile = folder + 'metadata';
  if (fs.existsSync(metadataFile)) {
    var metadata = fs.readFileSync(metadataFile, 'utf8');
    return metadata.split('\n')[1];
  }
}

// Terminate with an error message
function error() {
  print.apply(this, arguments);
  process.exit(1);
}
